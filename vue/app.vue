<template>
  <div>
    <vuci-form uci-config="task_one" :key="counter">
      <vuci-typed-section title="Test" :columns="columns" type="test">
        <template #name="{ s }">
          <vuci-form-item-dummy
            :uci-section="s"
            name="name"
          ></vuci-form-item-dummy>
        </template>
        <template #address="{ s }">
          <vuci-form-item-dummy
            :uci-section="s"
            name="address"
          ></vuci-form-item-dummy>
        </template>
        <template #netmask="{ s }">
          <vuci-form-item-dummy
            :uci-section="s"
            name="netmask"
          ></vuci-form-item-dummy>
        </template>
        <template #actions="{ s }">
          <a-button type="primary" @click="handleEditSection({ s })"
            >Edit</a-button
          >
          <a-button type="danger" @click="deleteSection({ s })"
            >Delete</a-button
          >
        </template>
      </vuci-typed-section>
      <template #footer>
        <div class="create">
          <a-form-model-item
            style="width : 30%"
            label="Interface name"
            prop="text"
          >
            <a-input v-model="form.name" name="name" @blur="clearValidity" />
            <p class="inputError" v-if="!form.isValid">Field cannot be empty</p>
            <p class="inputError" v-if="!form.nameIsValid">This name already exists</p>
          </a-form-model-item>
          <a-form-item>
            <a-button type="primary" @click="createSection">Create</a-button>
          </a-form-item>
        </div>
      </template>
    </vuci-form>
    <task-modal
      :counter="counter"
      @closeModal="handleModal"
      :toggleModal="toggleModal"
      :sectionId="sectionId"
    ></task-modal>
  </div>
</template>

<script>
import TaskModal from './interfaces/TaskModal.vue'
export default {
  components: {
    TaskModal
  },
  data () {
    return {
      // komponentas reikalauja array, kuriame butu nurodyta :
      // dataIndex - required (kad galetu sumatchint data ir data-source)
      // title : c.label - required (unless button column)
      // optional
      // titleSlot/width
      // variable for typed section columns
      columns: [
        { name: 'name', label: 'Interface' },
        { name: 'address', label: 'Address' },
        { name: 'netmask', label: 'Netmask' },
        { name: 'actions', label: '' }
      ],
      // variable for new section form (validations + input value)
      form: {
        name: '',
        isValid: true,
        nameIsValid: true
      },
      // variable to target sectionId for modals (new + edit) and for delete
      sectionId: '',
      // variable for duplicate name check (could be not necessary, as typed section gets an unique name)
      // variable to re-fetch data from uci file
      counter: 0,
      // variable for modal toggling
      toggleModal: false,
      // ant design styling related variables
      labelCol: { span: 8 },
      wrapperCol: { span: 10 }
    }
  },
  methods: {
    // method implied after click of create button
    async createSection () {
      const foundName = this.getAllSections(this.form.name)
      // checking whether there is duplicate names + check whether input field is not empty
      if (!this.form.name) {
        this.form.isValid = false
      } 
      else if (foundName) {
        this.form.nameIsValid = false
      }
       else {
        // if validations are passed, validation messages are cleared
        this.clearValidity()
        // adding new section
        this.$uci.add('task_one', 'test')
        // extracting added last section from section array
        const sections = this.$uci.sections('task_one', 'test')
        const lastIndex = sections.length - 1
        const sid = sections[lastIndex]['.name']
        // setting name value of last section to input value
        this.$uci.set('task_one', sid, 'name', this.form.name)
        // saving all changes to uci file
        await this.$uci.save().then(() => {
          // applying all changes to uci file
          this.$uci.apply()
          // increasing counter to re-render typed section component
          this.counter++
        })
        // clearing form
        this.form.name = ''
        // clearing sectionId just in case and assigning new id generated by uci plugin (new****), it is not the same as one in uci file
        // thus need to getLastSection from updated uci file (async needed)
        this.sectionId = ''
        this.sectionId = await this.getLastSectionId()
        this.counter++
        this.handleModal()
      }
    },
    async getLastSectionId () {
      await this.$uci.load('task_one')
      const sections = this.$uci.sections('task_one', 'test')
      const lastSectionIndex = sections.length - 1
      return sections[lastSectionIndex]['.name']
    },
    handleModal () {
      this.counter++
      this.toggleModal = !this.toggleModal
    },
    clearValidity () {
      this.form.isValid = true
      this.form.nameIsValid = true
    },
    // getting name/id of typed section to pass it to named section in modal
    handleEditSection (s) {
      this.sectionId = ''
      this.sectionId = s.s['.name']
      this.counter++
      this.handleModal()
    },
    deleteSection (s) {
      this.$uci.del('task_one', s.s['.name'])
      this.$uci.save().then(() => {
        this.$uci.apply()
        this.counter++
      })
    },
    getAllSections (name) {
      // gets all sections from uci file
      const sections = this.$uci.sections('task_one', 'test')
      // maps through sections to extract only option name
      const names = sections.map(s => {
        return s.name
      })
      // search whether name in form exists in already applied sections in uci file
      const foundName = names.find(e => e === name)
      if (typeof (foundName) === 'undefined') {
        return false
      } else return true
    }
  }
}
</script>
<style scoped>
.create {
  display: flex;
}
.inputError {
  color: red;
}
</style>
